<원리>

1. 이것의 논리 : 두개의 스택으로 연산 수행하기

사용자에게 문자열로 입력받기 떄문에 우리는 그 문자열을 실제 숫자와 연산자로 분리해야됨
이를 위해 두개의 스택이 사용되며 숫자스택을 N, 연산자스택을 op라고 한다
이때 입력받은 문자열을 한 문자씩 돌아가며 이것이 숫자인지 연산자인지를 판별할 것이며
숫자일 경우에는 숫자스택에, 연산자일 경우에는 연산자스택에 집어넣는다
분리가 끝났으면 연산자를 하나씩 뽑아서 따로 빼둔 숫자들을 가지고 연산해야한다

2. 핵심기술1 : 분리한 숫자를 진짜 숫자로 변환하기

문자열로 입력받은 숫자 '0'의 아스키코드는 실제 숫자값 0에 48을 더한값인 48이다
예를들어 '1'의 아스키코드값은 49이고 '2'의 아스키코드값은 50이고 이런식이다
그렇기 때문에 입력받은 문자에서 48을 뺴주면 우리가 원하는 실제 값을 뽑아낼 수 있다

3. 핵심기술2 : 이어지는 숫자 진짜값으로 변환하기
만약 사용자가 10의자리 이상의 수를 입력했다고 가정해보자
120이라고 입력했을 경우 우리는 한문자씩 판별하기 때문에 1, 2, 0이라는 각각의 수는 알아도
그것의 자릿수까지 알아낼 수는 없다 그렇기 때문에 여기서는 int flag를 사용한다
맨 처음에는 flag를 0으로 설정하여 첫 입력값은 0의 flag로 수행하고 flag를 1로 바꿔줌으로써
이후에 이어지는 값들이 있을 경우 자릿수가 한자릿수가 아님을 알린다

위의 120을 예로 들어보면 '1'이라는 값을 판별했을떄 flag는 0인 상태다 그러므로 
아무런 의심 없이 숫자스택에 집어넣을 수 있다 그런다음 flag를 1로 바꿔주어 다음 입력을 대비한다

이후 '2'라는 값을 판별했을때 flag는 1인 상태다 그러므로 아까 집어넣었던 1을 다시 꺼내서
1*10+2=12라는 과정을 거쳐서 다시 집어넣어준다 여전히 flag는 1인 상태이며
숫자스택에는 아까 넣었던 1을 제거해준 후 12라는 올바른 값을 집어넣어준다

이후 '0'라는 값을 판별했을때 flag는 1인 상태다 그러므로 아까 집어넣었던 12를 다시 꺼내서
12*10+0=120라는 과정을 거쳐서 다시 집어넣어준다 여전히 flag는 1인 상태이며
숫자 스택에는 아까 넣었던 12를 제거해준 후 120이라는 올바를 값을 집어넣어준다

이떄 주의해야할 점은 다음번 판별한 문자가 연산자였을 경우 flag를 0으로 다시 초기화해주는 것이다
그렇게 함으로써 120+7이라는 식은 '7'을 검사할때 다시 flag0인 상태에서 검사할 수 있다

'=================================================
<실제 코드 설명>

#include <stdio.h>
#include <string.h>
#include <stack>				//stack 자료구조를 사용하기 위해 include

int main(){
	stack<long long int> N;		//long long int타입의 자료형을 저장할 수 있는 N이라는 이름의 stack을 생성
	stack<char> op;			//char타입의 자료형을 저장할 수 있는 op라는 이름의 stack을 생성
	char ex[60]={};			//입력받는 문자열을 저장할 ex라는 이름의 공간 마련
	long long int res=0, x=0, y=0;	
	int flag=0;			//flag는 지금 검사하는 값이 방금전의 문자와 이어지는 값인지 여부를
					//판별하기 위해 사용하며 맨 처음에는 0으로 설정해 줌으로써 아직 안이어졌음을 알린다

	scanf("%s", ex);			//아까 마련한 ex라는 이름의 공간에 입력받는다

	for(int i=0;i<strlen(ex); i++){		//입력받은 문자열에서 숫자와 연산자를 분리하여 서로 다른 stack에 집어넣을거임
		if('0'<=ex[i]&&ex[i]<='9'){    //만약 이번에 검사한 값이 숫자일 경우
			if(flag==1){	//첫번째 문자가 아닐 경우 방금 전의 값과 이어진 숫자임을 알려야하므로
			  x=N.top();	//일단 방금 숫자스택 N에 저장했던 애를 빼서 x에 넣고
			  y=ex[i]-48;	//y에는 방금전 문자의 실제값을 뽑아서 저장하고 (ex[i]-48으로 아스키코드 이용해 변환)
			  N.pop();	//x에다 저장도 했겠다 이전에 저장했던 숫자 pop으로 지워버림
			  N.push(x*10+y);  //이제 x와 y값 혼합해서 1, 2였다면 1*10+2=12로 12로 만들어준다음 숫자스택N에 저장
			}
			else(N.push(ex[i]-48);	  //첫번쨰 문자였을 경우 이번에는
				flag=1;	 	  //flag를 1로 설정해준다
			}
		}
		else{op.push(ex[i]);	//만약 이번에 검사한 값이 숫자가 아닐 경우 연산자라는 뜻이므로 연산자스택 op에 저장
		flag=0;		//이전까지 이어지던 숫자는 리셋되어 flag=0으로 설정
		}
		}

		while(!op.empty()){  	//사칙연산 수행할것이 아직 남아있는한 계속 연산을 수행해야 하므로 그때까지 무한루프 돈다
			x=N.top();             //숫자스택N의 맨 위에값 뽑아서 x에 저장한 다음
			N.pop();		//저장도 했겠다 숫자스택N 맨윗칸 pop으로 지워버림
	
				if(op.top()=='*'){		//사칙연산자들을 저장한 stack에서 맨 위에 있는 연산자가 곱셈일 경우
					y=N.top();	//x와 연산할 다음 숫자를 숫자스택N에서 뽑아낸 후 y에 저장
					N.pop();		//저장도 했겠다 N에선 pop으로 제거
					N.push(x*y);	//이번 연산자에 해당하는 연산을 수행하여 다시 숫자스택 N에 넣어준다
				}
				else if(op.top()=='+'){	//사칙연산자들을 저장한 stack에서 맨 위에 있는 연산자가 덧셈일 경우
					res+=x;		//결과에 x값을 더한다
	
				else if(op.top()=='-')	//사칙연산자들을 저장한 stack에서 맨 위에 있는 연산자가 뺄셈일 경우
					res-=x;		//결과에서 x값을 뺸다

			op.pop();		//stack 맨 위에있던 연산을 판별하여 수행했으므로 pop을 통해 제거한다
			}
		res+=N.top();			
		
		printf("%lld", res);

		return 0;
	}
