//시간복잡도 높은 알고리즘을 공간복잡도를 희생해서 줄이는 방식
//하지만 devide conquer의 경우 큰 문제를 쪼개서 해결하는 반면
//이건 연산 중복없이 하게된다(다이나믹 프로그래밍)
//
//동적계획법 사용하는 경우 특성 : 방법의수, 경우의수 등
//동적계획법 특징1. 부분문제의 중복
//		 2. 최적부분구조(작은문제답을 구하면 큰문제 답 구할 수 있다)
//동적계획법 푸는법 1. 탑다운 : 전체 문제를 세부로 쪼개고 해결
//		    2. 바텀업 : 작은 문제를 합쳐서 점점 키워나감
//=>여러 방법으로 풀어보고 왜 동적계획법으로밖에 안풀리는지를 보겠다
//
//<탑다운과 바텀업의 장단점>
//1. 탑다운 : 재귀적인것들을 옮겨놓은 방법, 나누는게 명확하게 보일때는
//		탑다운 쓰는게 좋음 다만 오버헤드 발생
//2. 바텀업 : 오버헤드 없고 공간복잡도 작음 그러나 직관적이지 않기 떄문에
//		n개 있을때 그 n개를 다봐야됨 시간복잡도 증가
//		근데 바텀업 해도 문제에서 요구하는시간 넘어가진 않을거다
//웨딩준비 문제: 예산이 한정돼있고 여러 품목별로 입어서 가장 근접한 조합을 찾음
//그리디 어프로치로 일단 시도해본다
//
//만약 분할정복 방식으로 풀게되면 전체 선택이 서로 독립적이게 된다
//첫번째 선택과 두번째 선택은 독립적이라 중복이 있으면 안되는 방식이다
//
//백트래킹 중에서도 완전 탐색법으로도 해보겠다
//이러면 시간 초과가 뜨겠지
//
//그럼 이제 드디어 탑다운 방식으로 
//1번 속성 증명 : 남은 예산 20이면 특정 두 예산의 합으로 분리가능
//속성 2개 만족하기때문에 사용 가능하다
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstring>
using namespace std;

int M, C, price[25][25];
int shop(int money, int g){//g는 지금까지 쓴돈
	if(money<0) return
		//tc : 문제 시도 횟수
		//price 맨 처음 원소 k라 가정하고 k번 돌려서 채워넣음
		//지난번에 배운건 stl문법인데 이번꺼는 아님
		//fill, memset 2가지 종류로 채워넣을 수 있다
		//fill : 시작지점~끝지점 주소사용
		//memset : c문법인데 string 계열 쓸때 memset으로 초기화했었지
		//g==c일 경우 모든 품목 조사한거니까 money에서 빼줬다

int main(void){
	//가장 비싼걸 먼저 선택하고 나머지로 여분 파악
	int M=20;
	int C=3;
 		
	return 0;
}
